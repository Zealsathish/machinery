# Internal consistency of system descriptions

There are cases where different parts of the system description describe the same aspect of a system in different ways. When a system description is generated by an inspection of an existing system, all parts of the description are consistent. But when modifying a description it can happen that inconsistencies are created by modifying different parts of the description in different ways. This document describes our approach how to handle the internal consistency of system descriptions.


## Examples of inconsistencies

When a system is inspected some data is duplicated. This happens for example when multiple scopes handle and store the same information.
An example is repositories: The repositories are queried and then stored in `manifest.json` by the repositories scope.
Additionally the files in `/etc/zypp/repos.d` contain the same information and are handled by unmanaged-files.
Another example are users and groups, which are handled by the scopes 'users' and 'groups'. The files `/etc/passwd`,
`/etc/shadow`, and `/etc/group` contain the same information. Configuration files are handled by the scope config-files.

Duplication of this data leads to problems like the same repository appearing multiple times on a build image because it's applied by the unmanaged-files and the repositories scope.

Another example are mount points. They are present in the description as the files where this information is contained. For changing this information or using it from other tools it would be desirable to have this information available in a more abstract form as well.


## Current Approach

The current approach is to avoid inconsistencies by filtering files duplicating information which is stored in the manifest. This is done either at inspection or on export.

During inspection for some scopes (e.g. for users and groups) all the information contained in the configuration files (`/etc/passwd` and `/etc/group` in the example) is put into the manifest. The file where the information is coming from then is not extracted by the inspection.

For other cases files duplicated information contained in the manifest is filtered out on export, when an image is build, or a kiwi or AutoYaST profile is exported. For example the yum configuration files are not exported, but new ones are created based on the information in the manifest. The list of these files is hard-coded in the exporter.

In a third case there is information in the system description, which is only used for information, but ignored otherwise (the diffs of config files relative to the version coming from its package).

So, the current approach tries no to apply config files when they are already covered on a more abstract level. This avoids duplication of data in some cases, but it has some issues:

* If extraction of information from a configuration file to the manifest is not 100% complete or accurate, information is lost.
* If the list of files filtered on export is not complete (for example when there is plugin configuration at a different location, the place where configuration is held is modified, additional information is fed in from a sysconfig file, or configuration is determined dynamically), there can be inconsistencies or broken setups in the exported data.
* There is no well-defined order how configuration is applied (in some cases the file overrides the manifest, in others it doesn't, in other cases information is not applies at all)

## Abstraction levels of configuration

The underlying issue is that configuration can be represented on different levels of abstraction:

### Raw data

Looking at configuration files as opaque objects preserves all the state, but doesn't provide insight into the actual configuration. This would be the represenation as raw data without any processing.

### Parsed raw data

If the format of a configuration file is known, it can be parsed into a more high-level representation maintaining all information in a generic way (e.g. parsing an INI-style config file into a JSON representation). This can provide some generic insight into the configuration, but requires the user to still have knowledge about the details of the configuration and how its represented. There also is a chance that some minor information is lost, when the parser is not perfect (e.g. comments, ordering of entries, etc.)

### Extracted information

For known configuration it's possible to explicitly extract the relevant configuration information from files and store it in a more general abstracted format in the manifest. This gives a high degree of insight, possibly across different ways and tools to manage the configuration. It is hard to make sure that all information is extracted, though. Especially if configuration changes, even a complete extraction might become inconsistent, without the user noticing it.

### Declarative configuration

The highest level of abstraction would be to have a declaration of intended result instead of concrete configuration settings. For example a service can be described like a black box (e.g. webserver listening on port 80) or in detail (e.g. apache's configuration files). This declarative configuration would be on the level which typically is handled by configuration management systems (such as Puppet or SaltStack). It might be hard or even impossible to extract information on this level from a system as it can require information about the intent of configuration, which might not be stored in the system itself. It often would be the desired level of abstraction when defining the configuration of a system. Typically it would be stored outside of the systems itself.


## Processing configuration

To get higher levels of abstraction it is necessary to process configuration files and data.

One challenge is to correctly process configuration. In some cases the only reliable way how to do that is to use the native tools using the configuration. As a middle ground existing abstractions of parsers, such as Augeas or what is in YaST could be helpful.

Another challenge is to where to process the data. In some cases it might be necessary to do that in the environment of the running system, in other cases, extracted data is enough.


## Use cases

Which level of abstraction is useful depends on the use case. Examples:

### Configuration discovery

When analysing a system, especially when trying to figure out what an unknown system does, all levels of abstraction are helpful. Even the same data on different levels can be helpful. The more data is available the more easy it is for the user to find and judge the configuration of the system.

### Replication of a system

When recovering a system or when replicating it in general, a higher abstraction is not necessary. Using raw data encapsulating the state of a system in its native form is the most reliable way to achieve an exact replication.

### Migration

For a migration use case it depends on what level of abstraction the migration is taking place. When it is a low-level migration such as migrating a physical to a virtual system, the use case is closer to a replication of a system. When it on a higher level, e.g. when moving a service from one operating system to another, the lower level configuration might simply not work because the config file format could have changed or even a different tool used which provides the same service (e.g. Lighttpd instead of Apache). But correct configuration can be deduced from the higher level representation.

For all migration use cases it is important that the result is in a consistent state, so that the target system is functional in itself.

### Editing a system description

When modifying a system description manually or programmatically, it depends on the knowledge of the user, what abstraction level is most convenient. If a user knows the format of a configuration file, it might be easiest to edit that directly. In other cases it might be more convenient to edit the abstract description, so that it can be used in a more abstract way and for example be applied to different target systems.

There can't be a clear preference here. The challenge is to avoid problems caused by inconsistencies of information on different levels.


## Requirements

In the context of the internal consistency of system description we have a number of requirements:

* No data should be lost, unless explicitly desired by the user.
* For gaining insight into a system it should be easy to get data, or add new functionality to gather additional data, or process existing data to get more insight.
* A system description obtained by inspection should be usable in different use cases, which might not be known yet during inspection. This means we don't know which level of abstraction we will need.
* There are more ways to get a system description besides inspection:
  * Creation of a system description using an editor
  * Composition of a system description using hierarchical templates
  * Import from a different format (e.g. kiwi, AutoYaST)
* When a description is applied or exported the result should be consistent and working.
* It should be transparent what happens during inspection and export, so that the user is able to diagnose and fix problems.
* The user should be in control of how configuration is applied and which level of abstraction is used depending on the use case.


## Concept

We need to define a concept which addresses the requirements in the context of the relevant use cases.
